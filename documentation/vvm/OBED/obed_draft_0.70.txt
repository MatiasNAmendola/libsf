+---------------------------------------+
|               OBED VM                 |
|                                       |
|  OBject/Event Driven Virtual Machine  |
|                                       |
|          February 22, 2014            |
|             Draft 0.70                |
|          by Rick C. Hodgin            |
|                                       |
|  Released as the Go-Forward prototype |
|  for the mechancis of the VVM engine. |
|  In prayer (much prayer)... -RCH      |
+----------------------------------------

+---------------------------------------+
|  A request in prayer, through faith   |
|---------------------------------------|
| May the Lord, Jesus Christ, bless the |
| work of my hands on this project, as  |
| I give all credit, honor, and glory   |
| to Him.  Amen.                        |
|---------------------------------------|
| May the Lord, Jesus Christ, bless the |
| work of all hands on this project, as |
| we give all credit, honor, and glory  |
| to Him.  Amen.                        |
+---------------------------------------+




Object/Event Driven Virtual Machine (OBED)
------------------------------------------

The machine boots up with a memory buffer beginning at offset 0.  Instantiates with a single
program object, which points to an initial environment.  This program was previously compiled
for operation on the OBED VM.  It is a BXML file that contains specific information for loading
into the OBED VM.


VARIABLE DEFINITIONS
--------------------
All OBED variables names are prefixed during compilation with a four-character sequence
identifying their type and locality.  These do not affect their relationship to outside-
facing variable names, but are used internally for processing.

The format conveys two parts, XYYY.

EXAMPLE:  p,l,g,t,v,r		-- Parameter, Local, Global, Thread global, Private, Return
          s08,s16,s32,s64	-- Signed 8-bit, 16-bit, 32-bit, and 64-bit
          u08,u16,u32,u64	-- Unsigned 8-bit, 16-bit, 32-bit, and 64-bit
          f32,f64			-- Floating point, 32-bit, 64-bit
		  bin				-- Bignum integer
		  bfp				-- Bignum floating point

NOTE:  These are defined in the code executed on the VM.  The debugger environment has
       settings which allow this naming convention to be hidden, 
       An example of a simplified variable name:
	   
              OBED VM sees:     ls64Foo
			
              In the debugger:  foo
			               Or:  lnFoo

						   
Global Objects Visible in the Debugger
--------------------------------------
	vvm							-- The top level object
	vvm.prg						-- A running program instance (this is the top level object
									visible to the running program.  It cannot see vvm objects.
	vvm.prg.glo					-- Global variables for this program
	vvm.prg.scr					-- Allocated screens (visible windows on the user's desktop)
	vvm.prg.scr.cvs				-- Allocated canvases (per screen)
	vvm.prg.cvs					-- Raw list of canvases allocated by program
	vvm.prg.scr.cvs.rgn			-- Allocated regions (per canvas)
	vvm.prg.rgn					-- Raw list of regions allocated by program
	vvm.prg.rgn.cbk.mou			-- Mouse callbacks (per region)
	vvm.prg.rgn.cbk.key			-- Keyboard callbacks (per region)
	vvm.prg.rgn.cbk.cus			-- Custom callbacks (per region)
	vvm.prg.snp					-- Code snippets compiled for the program
	vvm.prg.snp.par				-- Parameter variables for each snippet
	vvm.prg.snp.ret				-- Return variables for each snippet
	vvm.prg.snp.loc				-- Local variables for each snippet
	vvm.prg.snp.sco				-- Scoped variables for each snippet
	vvm.prg.dyn					-- Dynamic code snippets compiled for the program
	vvm.prg.dyn.par				-- Parameter variables for each dynamic snippet
	vvm.prg.dyn.ret				-- Return variables for each dynamic snippet
	vvm.prg.dyn.loc				-- Local variables for each dynamic snippet
	vvm.prg.dyn.sco				-- Scoped variables for each dynamic snippet
	vvm.prg.gti					-- Global timers for this program (timers which fire in their own new thread)
	vvm.prg.thr					-- Thread pool for this program
	vvm.prg.thr.sta				-- Thread stack
	vvm.prg.thr.reg				-- Thread CPU flags and registers
	vvm.prg.thr.tgl				-- Thread globals (global variables for this thread)
	vvm.prg.thr.tti				-- Thread timers (timers which will fire on the current thread)
	vvm.prg.thr.rsn				-- Running snippet (part of a hierarchical structure for call stack)
	vvm.prg.thr.rsn.par			-- Parameter variables for the current running snippet
	vvm.prg.thr.rsn.ret			-- Return variables for current running snippet
	vvm.prg.thr.rsn.loc			-- Local variables for current running snippet
	vvm.prg.thr.rsn.sco			-- Scoped variables for current running snippet
	vvm.prg.thr.ets				-- Currently executing thread snippet (vvm.prg.thr.ets.parent goes back up, etc.)

	* The following have future consideration:
	com							-- Communications object
	sec							-- Security objects

Variables
---------
	x.var.nam						-- Name and value of variable in ASCII
	x.var._uni						-- (if defined) name of the variable in UNICODE
	x.var._xunderflow				-- (If defined) Exception to trigger on variable underflow
	x.var._xoverflow				-- (If defined) Exception to trigger on variable overflow
	x.var._min						-- (If defined) Minimum value that can be stored in this value
	x.var._max						-- (If defined) Maximum value that can be stored in this value

VVM self-instantiates with an optional program to launch,
which lets it determine how the VVM will operate.  However,
if no program is specified, the VVM loads a default, internally
launched program which is basically an OSS-specific prompt
asking the user which disk-based BXML they desire to run.


Relative Pathnames
------------------
The VVM creates an isolated virtual environment, and supports a
home folder location that can always be identified within a pathname
as "//" followed by the relative portion.  This makes "//" its "root"
directory.  In this way, migrating suspended VVM instances from one
machine to another, or one session to another, allows their data
connections to persist, even if suspended and resumed later.


Dynamic Snippets
----------------
Dynamic Snippets exist as two distinct types.

(1) The first is something most developers will be familiar with.
It specifies the interface parameters in communicating with an
external DLL.  It is the prototype definition that is created in
the VVM, so that the VVM calls the appropriate dynamic snippet,
which then forwards on to the external DLL.  And, upon return,
based upon the return parameter(s), it translates information
from the DLL into VVM-specific variables.

(2) The VVM supports an edit-and-continue ABI, and this is how it
is implemented.  Initially (at the time of first compile), an
actual snippet is created.  However, if that snippet is replaced
in the debugger during runtime, a dynamic snippet takes its place.
A "forward pointer" from the snippet indicates which dynamic
snippet should be run in its place.  And with each subsequent
change either the dynamic snippet is updated (depending on the
nature of the change), or it is supplanted by a new dynamic
snippet with the previous one being moved into an anchor history
list if required.


Datum
------
	A Datum is the lowest-level primitive form for storing data.
	It is the root item used on every object, as each object
	reference has a name and associated data.  Both the name and
	the data are stored as Datums.  Every data has a name, and
	name length, and a data, and data length.  There is also a
	Datum2 which allows a "logical size" to be created, which
	is not allocated, but indicates a maximum that can be allocated.

	
Object
------
	Every variable is an object.
	Every object is a container.
	Every object has a next and prev, which points to siblings.
	Every object has a parent (even singletons, whose parent is vvm.prg.glo object).

	
Memory
------
	All memory is linear per program.  No paging.  No mechanical swapping to disk.  So far as the VVM programs
	are concerned, there is an unlimited 64-bit flat memory area which extends from 0 upward.
	
	Memory is initially allocated beginning at offset 0 for some size (a VVM instance setting, minimum of 4MB).
	The VVM can launch paused with no program running.  From there, prior saved sessions can be restored, or
	programs can be loaded manually and run.
	
	Each program has a main, and it begins running at that location.  Every suspended and resumed process will
	maintain its last executing line, and will continue on from there upon resumption.  Only those functions
	which are not tagged (|NOSUSPEND|) can be suspended in.

// TODO:  working here...
	VARIOUS FIXED INTERNAL OBJECTS ARE MAINTAINED OUTSIDE OF MAIN MEMORY WHICH HOLD
	INFORMATION ABOUT THE RUNNING VM.  THESE ARE QUERIED BY THE HOST AND GUEST THROUGH
	A SPECIAL API.

	DYNAMIC CODE CAN BE LOADED AND IS UPDATED IN THE FIXED INTERNAL OBJECTS, AND IS
	STORED IN THE AREAS OF AVAILABLE MEMORY.

	EVERY OBJECT HAS A POINTER TO THE START OF THE NAME, OR START OF ASSOCIATED DATA.
	ALL REFERENCES TO EVERY DATUM WHICH EXIST ARE BY OBJECT NAMES.

EDIT-AND-CONTINUE
-----------------
	ALL CODE SUPPORTS EDIT-AND-CONTINUE.
	A THREAD CAN BE PAUSED, CODE CHANGED/REPLACED, AND THEN RESUMED ON A RUNNING VM.  IF OBED VM
    IDENTIFIES THAT ITEMS BEING UPDATED ARE IN USE IN OTHER THREADS, THOSE THREADS ARE SUSPENDED
    AUTOMATICALLY WHILE THE UPDATE TAKES PLACE.  THIS IS SUPPORTED USING THIS MODEL:

		LINE 1	-	JUMPS TO SNIPPET FOR LINE 1
					EXECUTES THAT LINE'S SNIPPET
                    JUMPS TO START OF LINE 2
		LINE 2	-	JUMPS TO SNIPPET FOR LINE 2

		PROCESS REPEATS FOR EACH SUCCESSIVE LINE.

	WHEN CHANGES ARE MADE, THE PROGRAM PORTIONS FOR EACH LINE ARE CHANGED,
	WITH NEW LINES BEING INSERTED, DELETED LINES BEING REMOVED, ETC.

	BY MAINTAINING THIS LINE-TO-SNIPPET RELATIONSHIP, EDIT-AND-CONTINUE
	BECOMES VERY EASY TO IMPLEMENT.  HOWEVER, THIS IS NOT THE ONLY MODEL.
	THE ENTIRE ABI CAN BE SWAPPED OUT AND REPLACED AS NECESSARY, PROVIDED
	THE INTEGRITY OF THE ENTIRE MACHINE STATE IS MAINTAINED.

REGISTERS
------------------------------------------
	REGISTERS ARE AUTOMATICALLY ALLOCATED FOR EACH CALLED SNIPPET.
	REGISTERS ARE RELATIONAL TO ONE ANOTHER IN THE SAME PHYSICAL REGISTER SPACE.
	THE LOWER 8-BITS ARE THE BASE.
	EACH SUCCESSIVE LARGER SIZE REGISTER INCLUDES THE LOWER REGISTER, PLUS NEW SPACE.
	HERE WE SEE BIT POSITIONS FOR REGISTERS.

     ___________________________________ _________________ ________ ________
    |                 X64               |       X32       |  X16   |   X8   |
    |........|........|........|........|........|........|........|........|
    63                                32                16        8        0

     ___________________________________ _________________ ________ ________
    |                FX64               |                FX32               |
    |........|........|........|........|........|........|........|........|
    63                                32                                   0

	OFFSET		CODE	INTEGER REGISTERS
	------		----	-----------------
	+000		n/a		RESULT							; Assembly instructions which return unique id numbers, indicate counts, etc., return their result here

	OFFSET		CODE	INTEGER REGISTERS
	------		----	-----------------
	+008		0000	A8		A16		A32		A64		; INTEGER, POINTER AND GENERAL PURPOSE REGISTERS
	+016		0001	B8		B16		B32		B64
	+024		0010	C8		C16		C32		C64
	+032		0011	D8		D16		D32		D64
	+040		0100	E8		E16		E32		E64
	+048		0101	F8		F16		F32		F64
	+056		0110	G8		G16		G32		G64
	+064		0111	H8		H16		H32		H64
	+072		1000	I8		I16		I32		I64
	+080		1001	J8		J16		J32		J64
	+088		1010	K8		K16		K32		K64
	+096		1011	L8		L16		L32		L64
	+104		1100	M8		M16		M32		M64
	+112		1101	N8		N16		N32		N64
	+120		1110	O8		O16		O32		A64
	+128		1111	P8		P16		P32		P64
	
	OFFSET		CODE	FLOATING POINT REGISTERS
	------		----	------------------------
	+136		0000	FA32	FA64					;  FLOATING POINT REGISTERS
	+144		0001	FB32	FB64
	+152		0010	FC32	FC64
	+160		0011	FD32	FD64
	+168		0100	FE32	FE64
	+176		0101	FF32	FF64
	+184		0110	FG32	FG64
	+192		0111	FH32	FH64
	+200		1000	FI32	FI64
	+208		1001	FJ32	FJ64
	+216		1010	FK32	FK64
	+224		1011	FL32	FL64
	+232		1100	FM32	FM64
	+240		1101	FN32	FN64
	+248		1110	FO32	FO64
	+256		1111	FP32	FP64

	OTHER REGISTERS (ACCESSIBLE ONLY BY SPECIAL INSTRUCTIONS)
	---------------------------------------------------------
	+264		FLAGS			- FLAGS
	+272		IP				- INSTRUCTION POINTER
	+280		SP				- STACK POINTER
	
	+288		SNIP			- CURRENTLY SNIPPET NUMBER EXECUTING
	+296		EXSNIP			- SNIPPET ID NUMBER TO BRANCH TO ON EXCEPTION
	
	+304		SB				- SANDBOX OFFSET (INCREASES UPON ALLOCATION, DECREASES UPON DEALLOCATION)
	+312		ERROR			- THE MACHINE OPCODE ERROR GENERATED DURING EXECUTION (SNIP:IP IS POINTING TO OFFENDING INSTRUCTION)
	
	+320		PRED			- PREDICATE FLAG SETTING, LOWER 24-BITS USED, 64-BITS STORAGE
	+328		PREDCOUNT		- PREDICATE COUNT, RESETS PRED TO 0 WHEN REACHES 0
	
	NOTE:  THERE ARE NO INSTRUCTIONS WHICH DIRECTLY AFFECT THESE REGISTERS.  THEY ARE SET/CLEARED BY THE DEBUGGER.
	+336		DSNP1			- A DEBUGGER REGISTER FOR BREAKPOINTS, THE INDICATED SNIPPET OR DYNAMIC SNIPPET
	+344		DOFF1			- OFFSET INTO THE SNIPPET'S MACHINE CODE BYTES FOR BREAKPOINT
	+352		DSNP2			- A DEBUGGER REGISTER FOR BREAKPOINTS, THE INDICATED SNIPPET OR DYNAMIC SNIPPET
	+360		DOFF2			- OFFSET INTO THE SNIPPET'S MACHINE CODE BYTES FOR BREAKPOINT
	+368		DSNP3			- A DEBUGGER REGISTER FOR BREAKPOINTS, THE INDICATED SNIPPET OR DYNAMIC SNIPPET
	+376		DOFF3			- OFFSET INTO THE SNIPPET'S MACHINE CODE BYTES FOR BREAKPOINT
	+384		DSNP4			- A DEBUGGER REGISTER FOR BREAKPOINTS, THE INDICATED SNIPPET OR DYNAMIC SNIPPET
	+392		DOFF4			- OFFSET INTO THE SNIPPET'S MACHINE CODE BYTES FOR BREAKPOINT


FLAGS (64-bits, only lower 24-bits shown populated, dots indicate unused bits)
------------------------------------------------------------------------------
    ........ ........ ........ ........ ........ 00000000 00000000 00000001   - CARRY?
    ........ ........ ........ ........ ........ 00000000 00000000 00000010   - OVERFLOW?
    ........ ........ ........ ........ ........ 00000000 00000000 00000100   - UNDERFLOW?
    ........ ........ ........ ........ ........ 00000000 00000000 00001000   - EQUAL?
    ........ ........ ........ ........ ........ 00000000 00000000 00010000   - ZERO?
    ........ ........ ........ ........ ........ 00000000 00000000 00100000   - NEGATIVE?
    ........ ........ ........ ........ ........ 00000000 00000000 01000000   - POSITIVE?
    ........ ........ ........ ........ ........ 00000000 00000000 10000000   - APP  - (aka APP0) AVAILABLE TO APPLICATION

    ........ ........ ........ ........ ........ 00000000 00000001 00000000   - APP1 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 00000010 00000000   - APP2 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 00000100 00000000   - APP3 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 00001000 00000000   - APP4 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 00010000 00000000   - APP5 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 00100000 00000000   - APP6 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 01000000 00000000   - APP7 - AVAILABLE TO APPLICATION
    ........ ........ ........ ........ ........ 00000000 10000000 00000000   - APP8 - AVAILABLE TO APPLICATION
	
    NOTE:  THERE ARE NO INSTRUCTIONS WHICH DIRECTLY AFFECT THESE REGISTERS.
           THEY ARE SET/CLEARED BY THE DEBUGGER, OR BY THE RUNTIME EXECUTION ENGINE.
    ........ ........ ........ ........ ........ 00000001 00000000 00000000   - IS_SUSPENDED?
    ........ ........ ........ ........ ........ 00000010 00000000 00000000   - IN_ERROR?
    ........ ........ ........ ........ ........ 00000100 00000000 00000000   - SINGLE_STEP?
    ........ ........ ........ ........ ........ 00001000 00000000 00000000   - DEBUG1_IS_ACTIVE?
    ........ ........ ........ ........ ........ 00010000 00000000 00000000   - DEBUG2_IS_ACTIVE?
    ........ ........ ........ ........ ........ 00100000 00000000 00000000   - DEBUG3_IS_ACTIVE?
    ........ ........ ........ ........ ........ 01000000 00000000 00000000   - DEBUG4_IS_ACTIVE?
    ........ ........ ........ ........ ........ 10000000 00000000 00000000   - EXTENDED_DEBUG_IS_ACTIVE?


PREDICATE (64-bits, only lower 24-bits shown are used)
------------------------------------------------------------------------------
    THESE VALUES BEING SET HAVE NO EFFECT ON VVM-CPU PROCESSING UNLESS THEIR BITS ARE SET IN THE NEXT BYTE:
    ........ ........ ........ ........ ........ 00000000 00000000 00000001   - CARRY?
    ........ ........ ........ ........ ........ 00000000 00000000 00000010   - OVERFLOW?
    ........ ........ ........ ........ ........ 00000000 00000000 00000100   - UNDERFLOW?
    ........ ........ ........ ........ ........ 00000000 00000000 00001000   - EQUAL?
    ........ ........ ........ ........ ........ 00000000 00000000 00010000   - ZERO?
    ........ ........ ........ ........ ........ 00000000 00000000 00100000   - NEGATIVE?
    ........ ........ ........ ........ ........ 00000000 00000000 01000000   - POSITIVE?
    ........ ........ ........ ........ ........ 00000000 00000000 10000000   - APP  - (aka APP0) AVAILABLE TO APPLICATION
    
    THE FOLLOWING BITS INDICATE IF THE FLAG CONDITIONS ABOVE ARE TO BE TESTED OR IGNORED:
    ........ ........ ........ ........ ........ 00000000 00000001 00000000   - CARRY?		IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 00000010 00000000   - OVERFLOW?	IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 00000100 00000000   - UNDERFLOW?	IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 00001000 00000000   - EQUAL?		IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 00010000 00000000   - ZERO?		IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 00100000 00000000   - NEGATIVE?	IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 01000000 00000000   - POSITIVE?	IS A VALID BOOLEAN CONDITION?
    ........ ........ ........ ........ ........ 00000000 10000000 00000000   - APP?		IS A VALID BOOLEAN CONDITION?

    THESE VALUES CAN ONLY BE TESTED FOR THEIR SET (1) CONDITION, IF 0 IGNORED:	
    ........ ........ ........ ........ ........ 00000001 00000000 00000000   - APP1 IS SET
    ........ ........ ........ ........ ........ 00000010 00000000 00000000   - APP2 IS SET
    ........ ........ ........ ........ ........ 00000100 00000000 00000000   - APP3 IS SET
    ........ ........ ........ ........ ........ 00001000 00000000 00000000   - APP4 IS SET
    ........ ........ ........ ........ ........ 00010000 00000000 00000000   - APP5 IS SET
    ........ ........ ........ ........ ........ 00100000 00000000 00000000   - APP6 IS SET
    ........ ........ ........ ........ ........ 01000000 00000000 00000000   - APP7 IS SET
    ........ ........ ........ ........ ........ 10000000 00000000 00000000   - APP8 IS SET
	NOTE:  PRED REGISTER IS ONLY POPULATED BY TWO INSTRUCTIONS:  PREDICATE, COPYPRED
	NOTE:  PRED IS RESET TO 0 AFTER COUNT REACHES ZERO


GENERAL INSTRUCTION FORMAT
--------------------------
	[PREDICATE]										- THE PREDICATE COMES FROM A PRIOR INSTRUCTION
	[OPCODE][OPERANDS][LITERALS][IMMEDIATES]


INSTRUCTION FORMAT
------------------
[4:PREDICATE] PRECEDES EVERY OPCODE
	0000	- NO PREDICATE
	0001	- CARRY?
	0010	- EQUAL?
	0100	- ZERO?
	1000	- UNDERFLOW?
	1001	- OVERFLOW?
	1010	- NEGATIVE?
	1011	- POSITIVE?
	1100	- CARRY? AND NEGATIVE?
	1101	- CARRY? AND POSITIVE?
	1110	- OVERFLOW? OR UNDERFLOW?
	1111	- APP?

[12:EXTENDED PREDICATE, IMMEDIATE VALUES FOR "PREDICATE" ASSEMBLY INSTRUCTION]
	none are currently defined
	
[4:SOURCES]
	0000	IMM16				[16:ENCODED IMMEDIATELY AFTER THE OPCODES]
	0001	IMM32				[32:ENCODED IMMEDIATELY AFTER THE OPCODES]
	0010	IMM64				[64:ENCODED IMMEDIATELY AFTER THE OPCODES]
	0011	REGISTER			[4:NUMBER]
	0100	SP[N]				[32:RELATIVE OFFSET TO SP]
	0101	SBD[N]				[4:REG RELATIVE OFFSET TO SANDBOX BASE]
	0110	PARAM				[4:PARAMETER NUMBER]
	0111	RETURN				[4:RETURN NUMBER]
	1000	LOCAL				[32:NUMBER, IF NEGATIVE EXPLICIT LOCAL, IF POSITIVE DYNAMIC ALLOCATION]
	1001	GLOBALS				[32:NUMBER, IF NEGATIVE EXPLICIT GLOBAL, IF POSITIVE DYNAMIC ALLOCATION]
	1010	OBJECT				[32:NUMBER, IF NEGATIVE EXPLICIT OBJECT, IF POSITIVE DYNAMIC ALLOCATION]
	1011	REG+REG				[4:NUMBER][4:NUMBER]
	1100	FREG+FREG			[4:NUMBER][4:NUMBER]
	1101	[REG+IMM8]			[4:OBJECT NUMBER][8:OFFSET INTO OBJECT]
	1110	[REG+REG]			[4:OBJECT NUMBER][4:OFFSET INTO OBJECT]
	1111	RESULT				USES THE RESULT REGISTER FOR THIS SOURCE

	
[8:INSTRUCTION] - INSTRUCTION SET (OPCODE BYTE VALUES TO BE DEFINED LATER)
	* NOTE:  REFER TO OBED_DRAFT_0.60.ASSEMBLY_INSTRUCTIONS.TXT FOR EXPLICIT ENCODINGS AND SYNTAX OF EACH OPCODE
	x1111111	- EXTENDED INSTRUCTION BYTE FOLLOWS (TO BE DEFINED / ADDED LATER)
				EXAMPLES:
					SINE
					COSINE
					TANGENT
					ARCSINE
					ARCCOSINE
					ARCTANGENT
					SQUARE ROOT
					ROUND
					ISINT

DEBUGGER API
------------
WARNING:  THE PORTION BEYOND THIS LINE MAY NO LONGER BE ACCURATE.
          I WILL REVISIT IT IN THE COMING WEEKS.
	THIS API IS DESIGNED SO NUMEROUS EXTERNAL DEBUGGERS CAN CONNECT
	TO ANY RUNNING VM INSTANCE AND MONITOR, INFLUENCE OR DEVASTATE
	ITS NORMAL OPERATION INDEPENDENTLY.

	NOTE: THIS DEBUGGER INTERFACE IS SEPARATE AND ISOLATED FROM NORMAL
	WINDOW DEBUGGER ADHERENCE.  IT IS ITS OWN PROTOCOL AND WILL BE
	IMPLEMENTED IDENTICALLY ON ALL PLATFORMS, ALLOWING THE SAME DEBUGGER
	CODE TO OPERATE ON ALL PLATFORMS.
	
	THE FOLLOWING LIST OF FUNCTIONS ARE AVAILABLE TO EXTERNAL
	DEBUGGERS WISHING TO CONNECT TO A RUNNING VM INSTANCE.
	u32			debuggerRequestUniqueID						(void);
	
	THESE TWO FUNCTIONS ARE USED TO ATTACH A DEBUGGER.  THEY ARE
	AVAILABLE BY SENDING MESSAGES TO THE RUNNING VM INSTANCE.
	THE RESPONSE GIVEN BY THE VM INDICATES SUCCESS OR FAILURE:
	u32			debuggerConnect								(u32 id, s8* tcPath);
	u32			debuggerConnectRemote						(u32 id, s8* tcPath, s8* ipAddressOrMachineName);

	THE UNIQUE ID IS USED AS A "vvm_########.ini" FILE THAT IS POPULATED
	IN GENERAL WITH THIS INFORMATION:
		name=My Debugger's Name
		dll=c:\path\to\debugger.dll

	THE VVM ATTEMPTS TO LOCATE THE "vvmDebugger()" FUNCTION AND BEGINS
	A PROTOCOL TO IDENTIFY MUTUALLY REQUIRED PROCEDURE / FUNCTION
	LOCATIONS, ALLOWING THE VVM TO CALL THE DEBUGGER CODE DIRECTLY,
	AND THE DEBUGGER CODE TO CALL THE VVM DIRECTLY, ASYNCHRONOUSLY,
	AND IN A MULTI-THREADED CAPACITY (ALL FUNCTIONS ARE FULLY REENTRANT).
	
* In future this group may be renamed gui* instead of debugger*, as I
* am determining how I want plugins to operate within the VVM.  Plugins
* would request the same function addresses, but would do so without
* the logical context of "being a debugger".
* Refer to vvm_vdeb1.cpp, common_vvm.h for information about debugger functions.
